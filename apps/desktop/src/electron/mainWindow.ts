import {
    app,
    BrowserWindow,
    BrowserWindowConstructorOptions,
    ipcMain,
    shell,
    Tray
} from 'electron';
import contextMenu from 'electron-context-menu';
import isDev from 'electron-is-dev';
import * as fs from 'fs';
import path from 'path';
import { loadBounds, saveBounds } from './boundsSaver';
import { delay } from './utils';
import WebContentsRequest from './webContentsRequest';
import { handleMsg, initConnector, setServerUrl } from './wsMainWindowClient';
import { initCCServer } from './wsCCServer';
import { connectSqlite3 } from './db';
import { getAppInfo, setAppInfo } from './info';
import os from 'os';
import { getLocalIPAddress, killPort } from '@cicy/cicy-ws';
import util from 'util';
import { exec } from 'child_process';
const execPromise = util.promisify(exec);

const publicDir = path.resolve(__dirname, isDev ? '../../' : '../../../', 'public');

export function initDir() {
    const { appDataPath, meta } = getAppInfo();
    if (!fs.existsSync(path.join(appDataPath, 'bounds'))) {
        fs.mkdirSync(path.join(appDataPath, 'bounds'), { recursive: true });
    }
    if (!fs.existsSync(path.join(appDataPath, 'app'))) {
        fs.mkdirSync(path.join(appDataPath, 'app'), { recursive: true });
    }
    if (!fs.existsSync(path.join(appDataPath, 'data'))) {
        fs.mkdirSync(path.join(appDataPath, 'data'), { recursive: true });
    }
    if (!fs.existsSync(path.join(appDataPath, 'meta'))) {
        fs.mkdirSync(path.join(appDataPath, 'meta'), { recursive: true });
    }
    execPromise(`chmod +x "${meta.bin}"`).catch(console.error);
}

export function t(key: string) {
    return key;
}

contextMenu({
    showInspectElement: true,
    showSaveImageAs: false,
    showSearchWithGoogle: false,
    showLookUpSelection: false,
    showSelectAll: false,
    labels: {
        copy: t('Copy'),
        paste: t('paste')
    }
});
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const DEV_URL: string;

let openCvData = '';

export class MainWindow {
    static mainWindow: BrowserWindow | undefined = undefined;
    static windows: Map<string, BrowserWindow> = new Map();
    static windowsReady: Map<string, boolean> = new Map();
    static currentUrl: string = MAIN_WINDOW_WEBPACK_ENTRY;
    static tray: Tray | undefined = undefined;
    static getIcon() {
        return (() => {
            switch (process.platform) {
                case 'darwin':
                    return path.join(process.cwd(), 'public', 'icon.icns');
                case 'win32':
                    return path.join(process.cwd(), 'public', 'icon.ico');
                default:
                    return '';
            }
        })();
    }
    static getInfo() {
        return getAppInfo();
    }
    static getOptions() {
        const icon = this.getIcon();
        return {
            resizable: true,
            icon: icon,
            width: 1024,
            height: 820,
            webPreferences: {
                partition: 'persist:default',
                allowRunningInsecureContent: false,
                experimentalFeatures: false,
                spellcheck: false,
                nodeIntegration: true,
                contextIsolation: true,
                webviewTag: true,
                preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
            }
        } as BrowserWindowConstructorOptions;
    }

    static createTray(name?: string) {
        const tray = new Tray(path.resolve(publicDir, 'tray-icon.png'));
        tray.setToolTip(name || 'CiCy');
        tray.on('click', () => {
            console.log('tray clicked');
            const win = this.mainWindow;
            if (win) {
                if (win.isMinimized()) {
                    win.restore();
                }
                win.show();
                win.focus();
            }
        });
        this.tray = tray;
    }
    static getWinById(winId: string) {
        let win;
        if (winId && this.windows.get(winId)) {
            win = this.windows.get(winId);
        }
        if (winId && winId === 'main') {
            win = this.mainWindow;
        }
        return win;
    }
    static async createWindow({
        openDevTools,
        winId,
        url,
        windowOptions
    }: {
        openDevTools?: boolean;
        winId: string;
        url?: string;
        windowOptions: any;
    }) {
        let win = this.windows.get(winId);
        if (!win) {
            const { webPreferences, ...props } = this.getOptions();
            const { webPreferences: webPreferences1, ...props1 } = windowOptions;
            const savedBounds = loadBounds(winId);

            win = new BrowserWindow({
                ...props,
                webPreferences: {
                    ...webPreferences,
                    ...(webPreferences1 || {})
                },
                x: savedBounds?.x || 50 + 60,
                y: savedBounds?.y || 50 + 60,
                width: savedBounds?.width || 1024,
                height: savedBounds?.height || 820,
                ...props1
            });

            this.windows.set(winId, win);

            win.on('close', (e: any) => {
                let w = this.windows.get(winId);
                new WebContentsRequest(winId).clearRequests();

                this.windowsReady.delete(winId);
                this.windows.delete(winId);
                // this.handleProxyPorts(winId);
                if (w) {
                    saveBounds(winId, w.getBounds());
                    w = undefined;
                }
            });
            url && win.loadURL(url);
            new WebContentsRequest(winId).clearRequests();
        } else {
            if (win.isMinimized()) {
                win.restore();
            }
            win.show();
            win.focus();
        }
        if (openDevTools) {
            win.webContents.openDevTools({ mode: 'detach' });
        }
        return win;
    }
    static getAccountIndexByWinId(winId: string) {
        const row = winId.split('-');
        if (row.length === 2 && parseInt(row[0]) >= 0) {
            return parseInt(row[0]);
        } else {
            return null;
        }
    }
    static async handleProxyPorts(winId: string) {
        const accountIndex = this.getAccountIndexByWinId(winId);
        if (accountIndex !== null) {
            const accounts = Array.from(this.windows)
                .map(row => row[0])
                .map(row => row.split('-'))
                .filter(row => row.length === 2 && parseInt(row[0]) >= 0)
                .map(row => parseInt(row[0]));
            if (accounts.indexOf(accountIndex) === -1) {
                const port = 10000 + accountIndex;
                console.log('killPort', port);

                try {
                    await killPort(port);
                } catch (e) {
                    console.error(e);
                }
                const port1 = 20000 + accountIndex;
                console.log('killPort', port1);
                try {
                    await killPort(port1);
                } catch (e) {
                    console.error(e);
                }
            }
        }
    }

    static async openMainWindow() {
        if (this.mainWindow !== undefined && this.mainWindow !== null) return this.mainWindow;
        const userDataPath = app.getPath('userData');
        const appDataPath = path.join(os.homedir(), '.cicy');
        const version = app.getVersion();
        const ip = getLocalIPAddress();
        const isWin = process.platform === 'win32';
        const pathSep = isWin ? '\\' : '/';

        const getMetaInfo = (isWin: boolean) => {
            const configPath = path.join(appDataPath, 'meta', 'config.yaml');
            const dataDir = path.join(publicDir, 'static', 'meta', 'data');
            const bin = path.join(publicDir, 'static', 'meta', 'bin', `meta${isWin ? '.exe' : ''}`);
            return { bin, dataDir, configPath };
        };
        setAppInfo({
            ip: ip ? ip.adr : '127.0.0.1',
            isWin,
            pathSep,
            appDataPath,
            meta: getMetaInfo(isWin),
            publicDir,
            appDir: path.dirname(path.dirname(path.dirname(publicDir))),
            userDataPath,
            version,
            isDev
        });

        initDir();
        const savedBounds = loadBounds('default');
        this.mainWindow = new BrowserWindow({
            ...this.getOptions(),
            autoHideMenuBar: false,
            x: savedBounds?.x || 50,
            y: savedBounds?.y || 50,
            width: savedBounds?.width || 1024,
            height: savedBounds?.height || 768
        });

        if (DEV_URL) {
            this.currentUrl = DEV_URL;
        } else {
            // this.currentUrl = 'https://cicy.pages.dev';
        }

        console.log('[+] CurrentUrl:', this.currentUrl);
        console.log('[+] userDataPath:', userDataPath);
        console.log('[+] publicDir:', publicDir);

        try {
            const data = fs.readFileSync(path.resolve(publicDir, 'opencv.js'), 'utf8');
            openCvData = data.trim();
            connectSqlite3(path.join(appDataPath, 'data', 'app.db'));
        } catch (err) {
            console.error('Error reading file: opencv.js', err);
        }

        ipcMain.handle('message', async (e: any, message: { action: string; payload: any }) => {
            if (!['utils', 'db'].includes(message.action)) {
                console.log('[+] [MSG]', message);
            }

            const { action, payload } = message || {};
            switch (action) {
                case 'openPath': {
                    const { path } = payload || {};
                    if (fs.existsSync(path)) {
                        await shell.openPath(path); // Opens in file explorer/finder
                    } else {
                        console.warn('[!] path not found:', path);
                    }
                    break;
                }
                case 'connectCCServer': {
                    setServerUrl(payload.serverUrl);
                    break;
                }
                case 'getOpenCv': {
                    return openCvData;
                }
                case 'getAppInfo': {
                    return getAppInfo();
                }
                case 'initCCServer': {
                    await initCCServer(
                        payload.serverIp,
                        payload.serverPort,
                        payload.token,
                        payload.useRust
                    );
                    return true;
                }
                case 'initConnector': {
                    await initConnector(payload.serverUrl);
                    return true;
                }
                default: {
                    return handleMsg(action, payload);
                }
            }
        });
        await this.mainWindow.loadURL(this.currentUrl);

        this.mainWindow.on('close', () => {
            saveBounds('default', this.mainWindow.getBounds());
            this.windows.forEach(win => {
                win.close();
            });
            if (this.tray) {
                this.tray.destroy();
                this.tray = undefined;
            }
            ipcMain.removeHandler('siteMessage');
            ipcMain.removeHandler('message');

            this.mainWindow = undefined;
        });
        this.createTray();
        this.mainWindow.show();

        this.mainWindow.webContents.session.webRequest.onBeforeSendHeaders(
            { urls: [] },
            (details, callback) => {
                callback(details);
            }
        );

        this.mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
            callback(details);
        });

        await delay(500);
        return this.mainWindow;
    }

    static getCurrentUrl() {
        return this.currentUrl;
    }

    static async bringToFront() {
        if (process.platform === 'win32') {
            if (this.mainWindow) {
                if (this.mainWindow.isMinimized()) this.mainWindow.restore();
            } else {
                await this.openMainWindow();
            }

            this.mainWindow.setAlwaysOnTop(true);
            this.mainWindow.focus();
            this.mainWindow.setAlwaysOnTop(false);
        } else {
            await this.openMainWindow();
        }

        return this.mainWindow;
    }
}
