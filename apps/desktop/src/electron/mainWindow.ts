import {
    app,
    BrowserWindow,
    BrowserWindowConstructorOptions,
    globalShortcut,
    ipcMain,
    shell,
    Menu,
    Tray
} from 'electron';
import contextMenu from 'electron-context-menu';
import isDev from 'electron-is-dev';
import * as fs from 'fs';
import path from 'path';
import { loadBounds, saveBounds } from './boundsSaver';
import { delay } from './utils';
import WebContentsRequest from './webContentsRequest';
import { handleMsg, initCCClient, setServerUrl } from './wsMainWindowClient';
import { initCCServer } from './wsCCServer';
import { connectSqlite3 } from './db';
import { getAppInfo, setAppInfo } from './info';
import os from 'os';

const publicDir = path.resolve(__dirname, isDev ? '../../' : '../../../', 'public');

export function initDir() {
    const { appDataPath } = getAppInfo();
    if (!fs.existsSync(path.join(appDataPath, 'bounds'))) {
        fs.mkdirSync(path.join(appDataPath, 'bounds'), { recursive: true });
    }
    if (!fs.existsSync(path.join(appDataPath, 'app'))) {
        fs.mkdirSync(path.join(appDataPath, 'app'), { recursive: true });
    }
    if (!fs.existsSync(path.join(appDataPath, 'data'))) {
        fs.mkdirSync(path.join(appDataPath, 'data'), { recursive: true });
    }
}

export function t(key: string) {
    return key;
}

contextMenu({
    showInspectElement: true,
    showSaveImageAs: false,
    showSearchWithGoogle: false,
    showLookUpSelection: false,
    showSelectAll: false,
    labels: {
        copy: t('Copy'),
        paste: t('paste')
    }
});
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const DEV_URL: string;

let focusedWin: BrowserWindow | undefined = undefined;

let openCvData = '';

export class MainWindow {
    static mainWindow: BrowserWindow | undefined = undefined;
    static windows: Map<string, BrowserWindow> = new Map();
    static windowsReady: Map<string, boolean> = new Map();
    static currentUrl: string = MAIN_WINDOW_WEBPACK_ENTRY;
    static tray: Tray | undefined = undefined;
    static shortcutKeys: string[] = [
        'Cmd+Shift+W',
        'CommandOrControl+F',
        'CommandOrControl+W',
        'Escape'
    ];

    static getIcon() {
        return (() => {
            switch (process.platform) {
                case 'darwin':
                    return path.join(process.cwd(), 'public', 'icon.icns');
                case 'win32':
                    return path.join(process.cwd(), 'public', 'icon.ico');
                default:
                    return '';
            }
        })();
    }
    static getInfo() {
        return getAppInfo();
    }
    static getOptions() {
        const icon = this.getIcon();
        return {
            resizable: true,
            icon: icon,
            width: 1024,
            height: 780,
            webPreferences: {
                partition: 'persist:default',
                allowRunningInsecureContent: false,
                experimentalFeatures: false,
                spellcheck: false,
                nodeIntegration: true,
                contextIsolation: true,
                webviewTag: true,
                preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
            }
        } as BrowserWindowConstructorOptions;
    }

    static createTray(name?: string) {
        const tray = new Tray(path.resolve(publicDir, 'tray-icon.png'));
        tray.setToolTip(name || 'CiCy');
        tray.on('click', () => {
            console.log('tray clicked');
            const win = this.mainWindow;
            if (win) {
                if (win.isMinimized()) {
                    win.restore();
                }
                win.show();
                win.focus();
            }
        });
        this.tray = tray;
    }
    static getWinById(winId: string) {
        let win;
        if (winId && this.windows.get(winId)) {
            win = this.windows.get(winId);
        }
        if (winId && winId === 'main') {
            win = this.mainWindow;
        }
        return win;
    }
    static async createWindow({
        openDevTools,
        winId,
        url,
        windowOptions
    }: {
        openDevTools?: boolean;
        winId: string;
        url?: string;
        windowOptions: any;
    }) {
        let win = this.windows.get(winId);
        if (!win) {
            const { webPreferences, ...props } = this.getOptions();
            const { webPreferences: webPreferences1, ...props1 } = windowOptions;
            const savedBounds = loadBounds(winId);

            win = new BrowserWindow({
                ...props,
                webPreferences: {
                    ...webPreferences,
                    ...(webPreferences1 || {})
                },
                x: savedBounds?.x || 50,
                y: savedBounds?.y || 50,
                width: savedBounds?.width || 1024,
                height: savedBounds?.height || 768,
                ...props1
            });

            this.windows.set(winId, win);

            win.on('close', (e: any) => {
                let w = this.windows.get(winId);
                if (w) {
                    saveBounds(winId, w.getBounds());
                    w = undefined;
                }

                new WebContentsRequest(winId).clearRequests();
                this.windowsReady.delete(winId);
                this.windows.delete(winId);
            });
            url && win.loadURL(url);
            this.onWinEvent(win);
            this.handleFocusAndBlure(win);
            new WebContentsRequest(winId).clearRequests();
        } else {
            if (win.isMinimized()) {
                win.restore();
            }
            win.show();
            win.focus();
        }
        if (openDevTools) {
            win.webContents.openDevTools({ mode: 'detach' });
        }
        return win;
    }
    static async openMainWindow() {
        if (this.mainWindow !== undefined && this.mainWindow !== null) return this.mainWindow;
        const userDataPath = app.getPath('userData');
        const appDataPath = path.join(os.homedir(), '.cicy');
        const version = app.getVersion();

        setAppInfo({
            appDataPath,
            publicDir,
            userDataPath,
            version,
            isDev
        });

        initDir();
        const savedBounds = loadBounds('default');
        this.mainWindow = new BrowserWindow({
            ...this.getOptions(),
            autoHideMenuBar: false,
            x: savedBounds?.x || 50,
            y: savedBounds?.y || 50,
            width: savedBounds?.width || 1024,
            height: savedBounds?.height || 768
        });
        console.log('[+] DEV_URL', DEV_URL || 'null');
        console.log('[+] CurrentUrl:', this.currentUrl);
        console.log('[+] userDataPath:', userDataPath);
        console.log('[+] publicDir:', publicDir);

        try {
            const data = fs.readFileSync(path.resolve(publicDir, 'opencv.js'), 'utf8');
            openCvData = data.trim();
            connectSqlite3(path.join(appDataPath, 'data', 'app.db'));
        } catch (err) {
            console.error('Error reading file: opencv.js', err);
        }
        if (DEV_URL) {
            this.currentUrl = DEV_URL;
        }
        await this.mainWindow.loadURL(this.currentUrl);

        ipcMain.handle('message', async (e: any, message: { action: string; payload: any }) => {
            console.log('[+] [MSG]', message);
            const { action, payload } = message || {};
            switch (action) {
                case 'openPath': {
                    const { path } = payload || {};
                    if (fs.existsSync(path)) {
                        await shell.openPath(path); // Opens in file explorer/finder
                    } else {
                        console.warn('[!] path not found:', path);
                    }
                    break;
                }
                case 'connectCCServer': {
                    setServerUrl(payload.serverUrl);
                    break;
                }
                case 'getOpenCv': {
                    return openCvData;
                }
                case 'getAppInfo': {
                    return getAppInfo();
                }
                default: {
                    return handleMsg(action, payload);
                }
            }
        });
        const menu = Menu.buildFromTemplate([
            {
                label: 'Edit',
                submenu: [
                    { role: 'undo' },
                    { role: 'redo' },
                    { type: 'separator' },
                    { role: 'cut' },
                    { role: 'copy' },
                    { role: 'reload' },
                    { role: 'paste' },
                    { role: 'selectAll' }
                ]
            }
        ]);

        Menu.setApplicationMenu(menu);

        this.mainWindow.on('closed', () => {
            saveBounds('default', this.mainWindow.getBounds());
            this.windows.forEach(win => {
                win.close();
            });
            if (this.tray) {
                this.tray.destroy();
                this.tray = undefined;
            }
            ipcMain.removeHandler('siteMessage');
            ipcMain.removeHandler('message');

            this.mainWindow = undefined;
        });
        this.handleFocusAndBlure(this.mainWindow);
        setInterval(() => {
            this.checkShortcutKeys();
        }, 2000);
        this.onWinEvent(this.mainWindow);
        this.createTray();
        this.mainWindow.show();

        this.mainWindow.webContents.session.webRequest.onBeforeSendHeaders(
            { urls: [] },
            (details, callback) => {
                callback(details);
            }
        );

        this.mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
            callback(details);
        });

        await initCCServer('0.0.0.0', 4444, true);
        initCCClient().catch(console.error);
        await delay(500);
        return this.mainWindow;
    }
    static onWinEvent(win: BrowserWindow) {
        win.on('enter-full-screen', () => {
            win.webContents.send('onMainMessage', {
                action: 'onFullScreen',
                payload: {
                    isFullScreen: true
                }
            });
        });

        win.on('leave-full-screen', () => {
            win.webContents.send('onMainMessage', {
                action: 'onFullScreen',
                payload: {
                    isFullScreen: false
                }
            });
        });
    }
    static isWinFocused(window?: BrowserWindow) {
        return window && !window.isDestroyed() && window.isVisible() && window.isFocused();
    }
    static checkShortcutKeys() {
        let focusedWin1: BrowserWindow | undefined = undefined;
        const { shortcutKeys } = this;
        [...Array.from(this.windows).map(row => row[1]), this.mainWindow].forEach(window => {
            if (this.isWinFocused(window)) {
                focusedWin1 = window;
            }
        });
        if (!focusedWin1) {
            focusedWin = undefined;
            // console.log("===>> shortcutKeys unregister")
            shortcutKeys.forEach(key => {
                if (globalShortcut.isRegistered(key)) {
                    globalShortcut.unregister(key);
                }
            });
        } else {
            if (focusedWin1 === focusedWin) {
                return;
            }
            shortcutKeys.forEach(key => {
                if (globalShortcut.isRegistered(key)) {
                    globalShortcut.unregister(key);
                }
            });
            focusedWin = focusedWin1;
            // console.log("===>> shortcutKeys onMainMessage",shortcutKeys,this.isWinFocused(focusedWin))
            shortcutKeys.forEach(key => {
                if (globalShortcut.isRegistered(key)) {
                    return;
                }
                globalShortcut.register(key, () => {
                    if (this.isWinFocused(focusedWin)) {
                        console.log('onShortcut');
                        focusedWin.webContents.send('onMainMessage', {
                            action: 'onShortcut',
                            payload: { key }
                        });
                    }
                });
            });
        }
    }

    static handleFocusAndBlure(win: BrowserWindow) {
        win.on('blur', () => {
            win.webContents.send('onMainMessage', {
                action: 'onBlur',
                payload: {}
            });
        });

        win.on('focus', () => {
            win.webContents.send('onMainMessage', {
                action: 'onFocus',
                payload: {}
            });
        });
    }

    static getCurrentUrl() {
        return this.currentUrl;
    }

    static async bringToFront() {
        if (process.platform === 'win32') {
            if (this.mainWindow) {
                if (this.mainWindow.isMinimized()) this.mainWindow.restore();
            } else {
                await this.openMainWindow();
            }

            this.mainWindow.setAlwaysOnTop(true);
            this.mainWindow.focus();
            this.mainWindow.setAlwaysOnTop(false);
        } else {
            await this.openMainWindow();
        }

        return this.mainWindow;
    }
}
